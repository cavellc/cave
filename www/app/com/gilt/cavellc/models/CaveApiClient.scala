/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.6
 * apidoc:0.8.16 http://www.apidoc.me/gilt/cave-llc/0.0.6/ning_1_8_client
 */
package com.gilt.cavellc.models {

/**
 * This entity describes a configured alert, what to check and how often.
 */
case class Alert(
                  id: _root_.scala.Option[String] = None,
                  description: String,
                  enabled: Boolean,
                  period: String,
                  condition: String,
                  handbookUrl: _root_.scala.Option[String] = None,
                  routing: Map[String, String] = Map.empty,
                  relatedMetrics: Seq[com.gilt.cavellc.models.AlertMetric] = Nil
                  )

/**
 * Information about a metric related to an alert.
 */
case class AlertMetric(
                        name: String,
                        tags: Map[String, String],
                        aggregator: _root_.scala.Option[com.gilt.cavellc.models.Aggregator] = None,
                        periodSeconds: _root_.scala.Option[Long] = None
                        )

/**
 * Authorization information for a user
 */
case class Auth(
                 token: String,
                 expires: _root_.org.joda.time.DateTime
                 )

/**
 * An issue affecting CAVE right now, or recently closed
 */
case class Issue(
                  description: String,
                  since: _root_.org.joda.time.DateTime,
                  until: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
                  )

/**
 * An organization or team user, with the role
 */
case class Member(
                   user: com.gilt.cavellc.models.User,
                   role: com.gilt.cavellc.models.Role
                   )

/**
 * This entity encapsulates metric data that can be stored in CAVE.
 */
case class Metric(
                   name: String,
                   tags: Map[String, String] = Map.empty,
                   timestamp: Long,
                   value: Double
                   )

/**
 * This entity encapsulates a data point for a metric.
 */
case class MetricData(
                       time: _root_.org.joda.time.DateTime,
                       value: Double
                       )

/**
 * This entity encapsulates data for a metric.
 */
case class MetricDataBulk(
                           metrics: Seq[com.gilt.cavellc.models.MetricData]
                           )

/**
 * This entity encapsulates information about a metric.
 */
case class MetricInfo(
                       name: String,
                       tags: Seq[String]
                       )

/**
 * An organization is a real-world customer of the CAVE service. Each organization
 * is identified by a name, which must be unique. Each organization can have one or
 * more teams associated with it, allowing for data to be segregated. Security is
 * managed with organization tokens. A token is created automatically for every new
 * organization.
 */
case class Organization(
                         name: String,
                         email: String,
                         notificationUrl: String,
                         tokens: Seq[com.gilt.cavellc.models.Token]
                         )

/**
 * The list of current and recent issues affecting CAVE
 */
case class Status(
                   current: Seq[com.gilt.cavellc.models.Issue],
                   recent: Seq[com.gilt.cavellc.models.Issue]
                   )

/**
 * Each team has its own data. A team can push data into CAVE by using an active
 * token. A team can have one or more tokens associated with it, allowing for
 * tokens to be rotated, for security purposes. A team is solely responsible for
 * administration of its tokens. A team token is created automatically for every
 * new team.
 */
case class Team(
                 name: String,
                 tokens: Seq[com.gilt.cavellc.models.Token]
                 )

/**
 * A token is a security string, used to authenticate requests. Some requests can
 * only be executed by the organization owner, and these must be authenticated with
 * an organization token. Other requests can only be executed by a team owner, and
 * these can be authenticated with either a team token, or an organization token.
 */
case class Token(
                  id: String,
                  description: String,
                  value: String,
                  created: _root_.org.joda.time.DateTime
                  )

/**
 * A user is a real-world person who is using the CAVE service. The user signs up
 * for CAVE, and then interacts with the service through the APIs. Every call to
 * the API needs to use a token that is obtained after a successful login.
 */
case class User(
                 firstName: String,
                 lastName: String,
                 email: String
                 )

/**
 * An organization associated with a user.
 */
case class UserOrganization(
                             name: String,
                             role: com.gilt.cavellc.models.Role
                             )

/**
 * A team associated with a user.
 */
case class UserTeam(
                     name: String,
                     role: com.gilt.cavellc.models.Role
                     )

/**
 * An aggregator for metric data
 */
sealed trait Aggregator

object Aggregator {

  /**
   * The number of events in the metric data set.
   */
  case object Count extends Aggregator { override def toString = "count" }
  /**
   * The smallest value in the metric data set.
   */
  case object Min extends Aggregator { override def toString = "min" }
  /**
   * The largest value in the metric data set.
   */
  case object Max extends Aggregator { override def toString = "max" }
  /**
   * The average of the values in the metric data set.
   */
  case object Mean extends Aggregator { override def toString = "mean" }
  /**
   * The most frequent value in the metric data set.
   */
  case object Mode extends Aggregator { override def toString = "mode" }
  /**
   * The middle value in the metric data set.
   */
  case object Median extends Aggregator { override def toString = "median" }
  /**
   * The sum of all values in the metric data set.
   */
  case object Sum extends Aggregator { override def toString = "sum" }
  /**
   * The standard deviation of all values in the metric data set.
   */
  case object Stddev extends Aggregator { override def toString = "stddev" }
  /**
   * The 99th percentile value in the metric data set.
   */
  case object P99 extends Aggregator { override def toString = "p99" }
  /**
   * The 99.9th percentile value in the metric data set.
   */
  case object P999 extends Aggregator { override def toString = "p999" }
  /**
   * The 95th percentile value in the metric data set.
   */
  case object P95 extends Aggregator { override def toString = "p95" }
  /**
   * The 90th percentile value in the metric data set.
   */
  case object P90 extends Aggregator { override def toString = "p90" }

  /**
   * UNDEFINED captures values that are sent either in error or
   * that were added by the server after this library was
   * generated. We want to make it easy and obvious for users of
   * this library to handle this case gracefully.
   *
   * We use all CAPS for the variable name to avoid collisions
   * with the camel cased values above.
   */
  case class UNDEFINED(override val toString: String) extends Aggregator

  /**
   * all returns a list of all the valid, known values. We use
   * lower case to avoid collisions with the camel cased values
   * above.
   */
  val all = Seq(Count, Min, Max, Mean, Mode, Median, Sum, Stddev, P99, P999, P95, P90)

  private[this]
  val byName = all.map(x => x.toString -> x).toMap

  def apply(value: String): Aggregator = fromString(value).getOrElse(UNDEFINED(value))

  def fromString(value: String): _root_.scala.Option[Aggregator] = byName.get(value)

}

/**
 * The role that a user has in an organization or team
 */
sealed trait Role

object Role {

  /**
   * The administrator of the organization/team. Can do all operations.
   */
  case object Admin extends Role { override def toString = "admin" }
  /**
   * A member of the organization/team. Can do most operations.
   */
  case object Member extends Role { override def toString = "member" }
  /**
   * A read-only user of the organization/team. Can only view data.
   */
  case object Viewer extends Role { override def toString = "viewer" }
  /**
   * A user associated indirectly to an organization, through at least one team.
   */
  case object Team extends Role { override def toString = "team" }

  /**
   * UNDEFINED captures values that are sent either in error or
   * that were added by the server after this library was
   * generated. We want to make it easy and obvious for users of
   * this library to handle this case gracefully.
   *
   * We use all CAPS for the variable name to avoid collisions
   * with the camel cased values above.
   */
  case class UNDEFINED(override val toString: String) extends Role

  /**
   * all returns a list of all the valid, known values. We use
   * lower case to avoid collisions with the camel cased values
   * above.
   */
  val all = Seq(Admin, Member, Viewer, Team)

  private[this]
  val byName = all.map(x => x.toString -> x).toMap

  def apply(value: String): Role = fromString(value).getOrElse(UNDEFINED(value))

  def fromString(value: String): _root_.scala.Option[Role] = byName.get(value)

}

}

package com.gilt.cavellc.models {

package object json {
  import play.api.libs.json.__
  import play.api.libs.json.JsString
  import play.api.libs.json.Writes
  import play.api.libs.functional.syntax._
  import com.gilt.cavellc.models.json._

  private[cavellc] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

  private[cavellc] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
    def writes(x: java.util.UUID) = JsString(x.toString)
  }

  private[cavellc] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
    import org.joda.time.format.ISODateTimeFormat.dateTimeParser
    dateTimeParser.parseDateTime(str)
  }

  private[cavellc] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
    def writes(x: org.joda.time.DateTime) = {
      import org.joda.time.format.ISODateTimeFormat.dateTime
      val str = dateTime.print(x)
      JsString(str)
    }
  }

  implicit val jsonReadsCaveLLCAggregator = __.read[String].map(Aggregator.apply)
  implicit val jsonWritesCaveLLCAggregator = new Writes[Aggregator] {
    def writes(x: Aggregator) = JsString(x.toString)
  }

  implicit val jsonReadsCaveLLCRole = __.read[String].map(Role.apply)
  implicit val jsonWritesCaveLLCRole = new Writes[Role] {
    def writes(x: Role) = JsString(x.toString)
  }

  implicit def jsonReadsCaveLLCAlert: play.api.libs.json.Reads[Alert] = {
    (
      (__ \ "id").readNullable[String] and
        (__ \ "description").read[String] and
        (__ \ "enabled").read[Boolean] and
        (__ \ "period").read[String] and
        (__ \ "condition").read[String] and
        (__ \ "handbook_url").readNullable[String] and
        (__ \ "routing").readNullable[Map[String, String]].map(_.getOrElse(Map.empty)) and
        (__ \ "related_metrics").readNullable[Seq[com.gilt.cavellc.models.AlertMetric]].map(_.getOrElse(Nil))
      )(Alert.apply _)
  }

  implicit def jsonWritesCaveLLCAlert: play.api.libs.json.Writes[Alert] = {
    (
      (__ \ "id").write[scala.Option[String]] and
        (__ \ "description").write[String] and
        (__ \ "enabled").write[Boolean] and
        (__ \ "period").write[String] and
        (__ \ "condition").write[String] and
        (__ \ "handbook_url").write[scala.Option[String]] and
        (__ \ "routing").write[Map[String, String]] and
        (__ \ "related_metrics").write[Seq[com.gilt.cavellc.models.AlertMetric]]
      )(unlift(Alert.unapply _))
  }

  implicit def jsonReadsCaveLLCAlertMetric: play.api.libs.json.Reads[AlertMetric] = {
    (
      (__ \ "name").read[String] and
        (__ \ "tags").readNullable[Map[String, String]].map(_.getOrElse(Map.empty)) and
        (__ \ "aggregator").readNullable[com.gilt.cavellc.models.Aggregator] and
        (__ \ "period_seconds").readNullable[Long]
      )(AlertMetric.apply _)
  }

  implicit def jsonWritesCaveLLCAlertMetric: play.api.libs.json.Writes[AlertMetric] = {
    (
      (__ \ "name").write[String] and
        (__ \ "tags").write[Map[String, String]] and
        (__ \ "aggregator").write[scala.Option[com.gilt.cavellc.models.Aggregator]] and
        (__ \ "period_seconds").write[scala.Option[Long]]
      )(unlift(AlertMetric.unapply _))
  }

  implicit def jsonReadsCaveLLCAuth: play.api.libs.json.Reads[Auth] = {
    (
      (__ \ "token").read[String] and
        (__ \ "expires").read[_root_.org.joda.time.DateTime]
      )(Auth.apply _)
  }

  implicit def jsonWritesCaveLLCAuth: play.api.libs.json.Writes[Auth] = {
    (
      (__ \ "token").write[String] and
        (__ \ "expires").write[_root_.org.joda.time.DateTime]
      )(unlift(Auth.unapply _))
  }

  implicit def jsonReadsCaveLLCIssue: play.api.libs.json.Reads[Issue] = {
    (
      (__ \ "description").read[String] and
        (__ \ "since").read[_root_.org.joda.time.DateTime] and
        (__ \ "until").readNullable[_root_.org.joda.time.DateTime]
      )(Issue.apply _)
  }

  implicit def jsonWritesCaveLLCIssue: play.api.libs.json.Writes[Issue] = {
    (
      (__ \ "description").write[String] and
        (__ \ "since").write[_root_.org.joda.time.DateTime] and
        (__ \ "until").write[scala.Option[_root_.org.joda.time.DateTime]]
      )(unlift(Issue.unapply _))
  }

  implicit def jsonReadsCaveLLCMember: play.api.libs.json.Reads[Member] = {
    (
      (__ \ "user").read[com.gilt.cavellc.models.User] and
        (__ \ "role").read[com.gilt.cavellc.models.Role]
      )(Member.apply _)
  }

  implicit def jsonWritesCaveLLCMember: play.api.libs.json.Writes[Member] = {
    (
      (__ \ "user").write[com.gilt.cavellc.models.User] and
        (__ \ "role").write[com.gilt.cavellc.models.Role]
      )(unlift(Member.unapply _))
  }

  implicit def jsonReadsCaveLLCMetric: play.api.libs.json.Reads[Metric] = {
    (
      (__ \ "name").read[String] and
        (__ \ "tags").readNullable[Map[String, String]].map(_.getOrElse(Map.empty)) and
        (__ \ "timestamp").read[Long] and
        (__ \ "value").read[Double]
      )(Metric.apply _)
  }

  implicit def jsonWritesCaveLLCMetric: play.api.libs.json.Writes[Metric] = {
    (
      (__ \ "name").write[String] and
        (__ \ "tags").write[Map[String, String]] and
        (__ \ "timestamp").write[Long] and
        (__ \ "value").write[Double]
      )(unlift(Metric.unapply _))
  }

  implicit def jsonReadsCaveLLCMetricData: play.api.libs.json.Reads[MetricData] = {
    (
      (__ \ "time").read[_root_.org.joda.time.DateTime] and
        (__ \ "value").read[Double]
      )(MetricData.apply _)
  }

  implicit def jsonWritesCaveLLCMetricData: play.api.libs.json.Writes[MetricData] = {
    (
      (__ \ "time").write[_root_.org.joda.time.DateTime] and
        (__ \ "value").write[Double]
      )(unlift(MetricData.unapply _))
  }

  implicit def jsonReadsCaveLLCMetricDataBulk: play.api.libs.json.Reads[MetricDataBulk] = {
    (__ \ "metrics").readNullable[Seq[com.gilt.cavellc.models.MetricData]].map(_.getOrElse(Nil)).map { x => new MetricDataBulk(metrics = x) }
  }

  implicit def jsonWritesCaveLLCMetricDataBulk: play.api.libs.json.Writes[MetricDataBulk] = new play.api.libs.json.Writes[MetricDataBulk] {
    def writes(x: MetricDataBulk) = play.api.libs.json.Json.obj(
      "metrics" -> play.api.libs.json.Json.toJson(x.metrics)
    )
  }

  implicit def jsonReadsCaveLLCMetricInfo: play.api.libs.json.Reads[MetricInfo] = {
    (
      (__ \ "name").read[String] and
        (__ \ "tags").readNullable[Seq[String]].map(_.getOrElse(Nil))
      )(MetricInfo.apply _)
  }

  implicit def jsonWritesCaveLLCMetricInfo: play.api.libs.json.Writes[MetricInfo] = {
    (
      (__ \ "name").write[String] and
        (__ \ "tags").write[Seq[String]]
      )(unlift(MetricInfo.unapply _))
  }

  implicit def jsonReadsCaveLLCOrganization: play.api.libs.json.Reads[Organization] = {
    (
      (__ \ "name").read[String] and
        (__ \ "email").read[String] and
        (__ \ "notification_url").read[String] and
        (__ \ "tokens").readNullable[Seq[com.gilt.cavellc.models.Token]].map(_.getOrElse(Nil))
      )(Organization.apply _)
  }

  implicit def jsonWritesCaveLLCOrganization: play.api.libs.json.Writes[Organization] = {
    (
      (__ \ "name").write[String] and
        (__ \ "email").write[String] and
        (__ \ "notification_url").write[String] and
        (__ \ "tokens").write[Seq[com.gilt.cavellc.models.Token]]
      )(unlift(Organization.unapply _))
  }

  implicit def jsonReadsCaveLLCStatus: play.api.libs.json.Reads[Status] = {
    (
      (__ \ "current").readNullable[Seq[com.gilt.cavellc.models.Issue]].map(_.getOrElse(Nil)) and
        (__ \ "recent").readNullable[Seq[com.gilt.cavellc.models.Issue]].map(_.getOrElse(Nil))
      )(Status.apply _)
  }

  implicit def jsonWritesCaveLLCStatus: play.api.libs.json.Writes[Status] = {
    (
      (__ \ "current").write[Seq[com.gilt.cavellc.models.Issue]] and
        (__ \ "recent").write[Seq[com.gilt.cavellc.models.Issue]]
      )(unlift(Status.unapply _))
  }

  implicit def jsonReadsCaveLLCTeam: play.api.libs.json.Reads[Team] = {
    (
      (__ \ "name").read[String] and
        (__ \ "tokens").readNullable[Seq[com.gilt.cavellc.models.Token]].map(_.getOrElse(Nil))
      )(Team.apply _)
  }

  implicit def jsonWritesCaveLLCTeam: play.api.libs.json.Writes[Team] = {
    (
      (__ \ "name").write[String] and
        (__ \ "tokens").write[Seq[com.gilt.cavellc.models.Token]]
      )(unlift(Team.unapply _))
  }

  implicit def jsonReadsCaveLLCToken: play.api.libs.json.Reads[Token] = {
    (
      (__ \ "id").read[String] and
        (__ \ "description").read[String] and
        (__ \ "value").read[String] and
        (__ \ "created").read[_root_.org.joda.time.DateTime]
      )(Token.apply _)
  }

  implicit def jsonWritesCaveLLCToken: play.api.libs.json.Writes[Token] = {
    (
      (__ \ "id").write[String] and
        (__ \ "description").write[String] and
        (__ \ "value").write[String] and
        (__ \ "created").write[_root_.org.joda.time.DateTime]
      )(unlift(Token.unapply _))
  }

  implicit def jsonReadsCaveLLCUser: play.api.libs.json.Reads[User] = {
    (
      (__ \ "first_name").read[String] and
        (__ \ "last_name").read[String] and
        (__ \ "email").read[String]
      )(User.apply _)
  }

  implicit def jsonWritesCaveLLCUser: play.api.libs.json.Writes[User] = {
    (
      (__ \ "first_name").write[String] and
        (__ \ "last_name").write[String] and
        (__ \ "email").write[String]
      )(unlift(User.unapply _))
  }

  implicit def jsonReadsCaveLLCUserOrganization: play.api.libs.json.Reads[UserOrganization] = {
    (
      (__ \ "name").read[String] and
        (__ \ "role").read[com.gilt.cavellc.models.Role]
      )(UserOrganization.apply _)
  }

  implicit def jsonWritesCaveLLCUserOrganization: play.api.libs.json.Writes[UserOrganization] = {
    (
      (__ \ "name").write[String] and
        (__ \ "role").write[com.gilt.cavellc.models.Role]
      )(unlift(UserOrganization.unapply _))
  }

  implicit def jsonReadsCaveLLCUserTeam: play.api.libs.json.Reads[UserTeam] = {
    (
      (__ \ "name").read[String] and
        (__ \ "role").read[com.gilt.cavellc.models.Role]
      )(UserTeam.apply _)
  }

  implicit def jsonWritesCaveLLCUserTeam: play.api.libs.json.Writes[UserTeam] = {
    (
      (__ \ "name").write[String] and
        (__ \ "role").write[com.gilt.cavellc.models.Role]
      )(unlift(UserTeam.unapply _))
  }
}
}



package com.gilt.cavellc {
import com.ning.http.client.{AsyncCompletionHandler, AsyncHttpClient, AsyncHttpClientConfig, Realm, Request, RequestBuilder, Response}

object Constants {

  val UserAgent = "apidoc:0.8.16 http://www.apidoc.me/gilt/cave-llc/0.0.6/ning_1_8_client"
  val Version = "0.0.6"
  val VersionMajor = 0

}

class Client(
              apiUrl: String,
              auth: scala.Option[com.gilt.cavellc.Authorization] = None,
              asyncHttpClient: AsyncHttpClient = Client.defaultAsyncHttpClient
              ) {
  import com.gilt.cavellc.models.json._
  import org.slf4j.Logger
  import org.slf4j.LoggerFactory

  val logger = LoggerFactory.getLogger(getClass)

  def alerts: Alerts = Alerts

  def metrics: Metrics = Metrics

  def organizations: Organizations = Organizations

  def statuses: Statuses = Statuses

  def teams: Teams = Teams

  def tokens: Tokens = Tokens

  def users: Users = Users

  object Alerts extends Alerts {
    override def getOrganizationsByOrganization(
                                                 organization: String,
                                                 limit: _root_.scala.Option[Int] = None,
                                                 offset: _root_.scala.Option[Int] = None
                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Alert]] = {
      val queryParameters = Seq(
        limit.map("limit" -> _.toString),
        offset.map("offset" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/alerts", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Alert]", r, _.validate[Seq[com.gilt.cavellc.models.Alert]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsByOrganization(
                                                  organization: String,
                                                  description: String,
                                                  enabled: Boolean,
                                                  period: String,
                                                  condition: String,
                                                  handbookUrl: _root_.scala.Option[String] = None,
                                                  routing: _root_.scala.Option[Map[String, String]] = None
                                                  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description),
        "enabled" -> play.api.libs.json.Json.toJson(enabled),
        "period" -> play.api.libs.json.Json.toJson(period),
        "condition" -> play.api.libs.json.Json.toJson(condition),
        "handbook_url" -> play.api.libs.json.Json.toJson(handbookUrl),
        "routing" -> play.api.libs.json.Json.toJson(routing)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/alerts", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def patchOrganizationsByOrganizationAndId(
                                                        organization: String,
                                                        id: String,
                                                        description: _root_.scala.Option[String] = None,
                                                        enabled: _root_.scala.Option[Boolean] = None,
                                                        period: _root_.scala.Option[String] = None,
                                                        handbookUrl: _root_.scala.Option[String] = None,
                                                        routing: _root_.scala.Option[Map[String, String]] = None
                                                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description),
        "enabled" -> play.api.libs.json.Json.toJson(enabled),
        "period" -> play.api.libs.json.Json.toJson(period),
        "handbook_url" -> play.api.libs.json.Json.toJson(handbookUrl),
        "routing" -> play.api.libs.json.Json.toJson(routing)
      )

      _executeRequest("PATCH", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizationsByOrganizationAndId(
                                                      organization: String,
                                                      id: String
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Alert]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def deleteOrganizationsByOrganizationAndId(
                                                         organization: String,
                                                         id: String
                                                         )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                                organization: String,
                                                                team: String,
                                                                limit: _root_.scala.Option[Int] = None,
                                                                offset: _root_.scala.Option[Int] = None
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Alert]] = {
      val queryParameters = Seq(
        limit.map("limit" -> _.toString),
        offset.map("offset" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/alerts", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Alert]", r, _.validate[Seq[com.gilt.cavellc.models.Alert]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                                 organization: String,
                                                                 team: String,
                                                                 description: String,
                                                                 enabled: Boolean,
                                                                 period: String,
                                                                 condition: String,
                                                                 handbookUrl: _root_.scala.Option[String] = None,
                                                                 routing: _root_.scala.Option[Map[String, String]] = None
                                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description),
        "enabled" -> play.api.libs.json.Json.toJson(enabled),
        "period" -> play.api.libs.json.Json.toJson(period),
        "condition" -> play.api.libs.json.Json.toJson(condition),
        "handbook_url" -> play.api.libs.json.Json.toJson(handbookUrl),
        "routing" -> play.api.libs.json.Json.toJson(routing)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/alerts", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def patchOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                                       organization: String,
                                                                       team: String,
                                                                       id: String,
                                                                       description: _root_.scala.Option[String] = None,
                                                                       enabled: _root_.scala.Option[Boolean] = None,
                                                                       period: _root_.scala.Option[String] = None,
                                                                       handbookUrl: _root_.scala.Option[String] = None,
                                                                       routing: _root_.scala.Option[Map[String, String]] = None
                                                                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description),
        "enabled" -> play.api.libs.json.Json.toJson(enabled),
        "period" -> play.api.libs.json.Json.toJson(period),
        "handbook_url" -> play.api.libs.json.Json.toJson(handbookUrl),
        "routing" -> play.api.libs.json.Json.toJson(routing)
      )

      _executeRequest("PATCH", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                                     organization: String,
                                                                     team: String,
                                                                     id: String
                                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Alert]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Alert", r, _.validate[com.gilt.cavellc.models.Alert]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def deleteOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                                        organization: String,
                                                                        team: String,
                                                                        id: String
                                                                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/alerts/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }
  }

  object Metrics extends Metrics {
    override def postOrganizationsByOrganization(
                                                  organization: String,
                                                  metrics: Seq[com.gilt.cavellc.models.Metric]
                                                  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "metrics" -> play.api.libs.json.Json.toJson(metrics)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/metrics", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                                 organization: String,
                                                                 team: String,
                                                                 metrics: Seq[com.gilt.cavellc.models.Metric]
                                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "metrics" -> play.api.libs.json.Json.toJson(metrics)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/metrics", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def getOrganizationsAndMetricNamesByOrganization(
                                                               organization: String
                                                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.MetricInfo]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/metric-names").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.MetricInfo]", r, _.validate[Seq[com.gilt.cavellc.models.MetricInfo]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsAndMetricNamesByOrganizationAndTeam(
                                                                              organization: String,
                                                                              team: String
                                                                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.MetricInfo]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/metric-names").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.MetricInfo]", r, _.validate[Seq[com.gilt.cavellc.models.MetricInfo]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizationsAndCheckMetricsByOrganization(
                                                                organization: String,
                                                                condition: String,
                                                                start: _root_.org.joda.time.DateTime,
                                                                end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                                interval: _root_.scala.Option[Int] = None
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]] = {
      val queryParameters = Seq(
        Some("condition" -> condition),
        Some("start" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(start)),
        end.map("end" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        interval.map("interval" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/check-metrics", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.MetricDataBulk", r, _.validate[com.gilt.cavellc.models.MetricDataBulk]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsAndCheckMetricsByOrganizationAndTeam(
                                                                               organization: String,
                                                                               team: String,
                                                                               condition: String,
                                                                               start: _root_.org.joda.time.DateTime,
                                                                               end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                                               interval: _root_.scala.Option[Int] = None
                                                                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]] = {
      val queryParameters = Seq(
        Some("condition" -> condition),
        Some("start" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(start)),
        end.map("end" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        interval.map("interval" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/check-metrics", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.MetricDataBulk", r, _.validate[com.gilt.cavellc.models.MetricDataBulk]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def getOrganizationsByOrganization(
                                                 organization: String,
                                                 metric: String,
                                                 tags: _root_.scala.Option[String] = None,
                                                 aggregator: com.gilt.cavellc.models.Aggregator,
                                                 period: Int,
                                                 start: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                 end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                 limit: _root_.scala.Option[Int] = None
                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]] = {
      val queryParameters = Seq(
        Some("metric" -> metric),
        tags.map("tags" -> _),
        Some("aggregator" -> aggregator.toString),
        Some("period" -> period.toString),
        start.map("start" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        end.map("end" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        limit.map("limit" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/metrics", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.MetricDataBulk", r, _.validate[com.gilt.cavellc.models.MetricDataBulk]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                                organization: String,
                                                                team: String,
                                                                metric: String,
                                                                tags: _root_.scala.Option[String] = None,
                                                                aggregator: com.gilt.cavellc.models.Aggregator,
                                                                period: Int,
                                                                start: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                                end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                                limit: _root_.scala.Option[Int] = None
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]] = {
      val queryParameters = Seq(
        Some("metric" -> metric),
        tags.map("tags" -> _),
        Some("aggregator" -> aggregator.toString),
        Some("period" -> period.toString),
        start.map("start" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        end.map("end" -> _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(_)),
        limit.map("limit" -> _.toString)
      ).flatten

      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/metrics", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.MetricDataBulk", r, _.validate[com.gilt.cavellc.models.MetricDataBulk]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }
  }

  object Organizations extends Organizations {
    override def post(
                       name: String,
                       email: String,
                       notificationUrl: String
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Organization] = {
      val payload = play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.Json.toJson(name),
        "email" -> play.api.libs.json.Json.toJson(email),
        "notification_url" -> play.api.libs.json.Json.toJson(notificationUrl)
      )

      _executeRequest("POST", s"/organizations", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Organization", r, _.validate[com.gilt.cavellc.models.Organization])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def getByName(
                            name: String
                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Organization]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Organization", r, _.validate[com.gilt.cavellc.models.Organization]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def patchByName(
                              name: String,
                              email: _root_.scala.Option[String] = None,
                              notificationUrl: _root_.scala.Option[String] = None
                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Organization] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email),
        "notification_url" -> play.api.libs.json.Json.toJson(notificationUrl)
      )

      _executeRequest("PATCH", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Organization", r, _.validate[com.gilt.cavellc.models.Organization])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def deleteByName(
                               name: String
                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def deleteMetricNamesByNameAndMetric(
                                                   name: String,
                                                   metric: String
                                                   )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/metric-names/${_root_.com.gilt.cavellc.PathSegment.encode(metric, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def getUsersByName(
                                 name: String
                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Member]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/users").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Member]", r, _.validate[Seq[com.gilt.cavellc.models.Member]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postUsersByName(
                                  name: String,
                                  email: String,
                                  role: com.gilt.cavellc.models.Role
                                  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email),
        "role" -> play.api.libs.json.Json.toJson(role)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/users", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def patchUsersByNameAndEmail(
                                           name: String,
                                           email: String,
                                           role: com.gilt.cavellc.models.Role
                                           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "role" -> play.api.libs.json.Json.toJson(role)
      )

      _executeRequest("PATCH", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/users/${_root_.com.gilt.cavellc.PathSegment.encode(email, "UTF-8")}", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def deleteUsersByNameAndEmail(
                                            name: String,
                                            email: String
                                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/users/${_root_.com.gilt.cavellc.PathSegment.encode(email, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }
  }

  object Statuses extends Statuses {
    override def getStatus()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Status]] = {
      _executeRequest("GET", s"/status").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Status", r, _.validate[com.gilt.cavellc.models.Status]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }
  }

  object Teams extends Teams {
    override def getOrganizationsByOrganization(
                                                 organization: String
                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Team]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Team]", r, _.validate[Seq[com.gilt.cavellc.models.Team]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsByOrg(
                                         org: String,
                                         name: String
                                         )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Team] = {
      val payload = play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.Json.toJson(name)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(org, "UTF-8")}/teams", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Team", r, _.validate[com.gilt.cavellc.models.Team])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def getOrganizationsByOrganizationAndTeam(
                                                        organization: String,
                                                        team: String
                                                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Team]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Team", r, _.validate[com.gilt.cavellc.models.Team]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def deleteOrganizationsAndMetricNamesByOrganizationNameAndTeamNameAndMetric(
                                                                                          organizationName: String,
                                                                                          teamName: String,
                                                                                          metric: String
                                                                                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organizationName, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(teamName, "UTF-8")}/metric-names/${_root_.com.gilt.cavellc.PathSegment.encode(metric, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def getOrganizationsAndUsersByOrganizationAndTeam(
                                                                organization: String,
                                                                team: String
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Member]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/users").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Member]", r, _.validate[Seq[com.gilt.cavellc.models.Member]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsAndUsersByOrganizationAndTeam(
                                                                 organization: String,
                                                                 team: String,
                                                                 email: String,
                                                                 role: com.gilt.cavellc.models.Role
                                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email),
        "role" -> play.api.libs.json.Json.toJson(role)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/users", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def patchOrganizationsAndUsersByOrganizationAndTeamAndEmail(
                                                                          organization: String,
                                                                          team: String,
                                                                          email: String,
                                                                          role: com.gilt.cavellc.models.Role
                                                                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "role" -> play.api.libs.json.Json.toJson(role)
      )

      _executeRequest("PATCH", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/users/${_root_.com.gilt.cavellc.PathSegment.encode(email, "UTF-8")}", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def deleteOrganizationsAndUsersByOrganizationAndTeamAndEmail(
                                                                           organization: String,
                                                                           team: String,
                                                                           email: String
                                                                           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/users/${_root_.com.gilt.cavellc.PathSegment.encode(email, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def deleteOrganizationsByOrganizationAndTeam(
                                                           organization: String,
                                                           team: String
                                                           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }
  }

  object Tokens extends Tokens {
    override def getOrganizationsByOrganization(
                                                 organization: String
                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Token]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/tokens").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Token]", r, _.validate[Seq[com.gilt.cavellc.models.Token]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsByOrganization(
                                                  organization: String,
                                                  description: String
                                                  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Token] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/tokens", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Token", r, _.validate[com.gilt.cavellc.models.Token])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def getOrganizationsByOrganizationAndId(
                                                      organization: String,
                                                      id: String
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Token]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/tokens/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Token", r, _.validate[com.gilt.cavellc.models.Token]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def deleteOrganizationsByOrganizationAndId(
                                                         organization: String,
                                                         id: String
                                                         )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/tokens/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                                organization: String,
                                                                team: String
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Token]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/tokens").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.Token]", r, _.validate[Seq[com.gilt.cavellc.models.Token]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                                 organization: String,
                                                                 team: String,
                                                                 description: String
                                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Token] = {
      val payload = play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.Json.toJson(description)
      )

      _executeRequest("POST", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/tokens", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Token", r, _.validate[com.gilt.cavellc.models.Token])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                                     organization: String,
                                                                     team: String,
                                                                     id: String
                                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Token]] = {
      _executeRequest("GET", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/tokens/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Token", r, _.validate[com.gilt.cavellc.models.Token]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def deleteOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                                        organization: String,
                                                                        team: String,
                                                                        id: String
                                                                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]] = {
      _executeRequest("DELETE", s"/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(organization, "UTF-8")}/teams/${_root_.com.gilt.cavellc.PathSegment.encode(team, "UTF-8")}/tokens/${_root_.com.gilt.cavellc.PathSegment.encode(id, "UTF-8")}").map {
        case r if r.getStatusCode == 204 => Some(Unit)
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 204, 404", r.getUri)
      }
    }
  }

  object Users extends Users {
    override def postRegister(
                               email: String
                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email)
      )

      _executeRequest("POST", s"/users/register", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def postConfirm(
                              firstName: String,
                              lastName: String,
                              password: String,
                              confirmationToken: String
                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.User] = {
      val payload = play.api.libs.json.Json.obj(
        "first_name" -> play.api.libs.json.Json.toJson(firstName),
        "last_name" -> play.api.libs.json.Json.toJson(lastName),
        "password" -> play.api.libs.json.Json.toJson(password),
        "confirmation_token" -> play.api.libs.json.Json.toJson(confirmationToken)
      )

      _executeRequest("POST", s"/users/confirm", body = Some(payload)).map {
        case r if r.getStatusCode == 201 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.User", r, _.validate[com.gilt.cavellc.models.User])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 201", r.getUri)
      }
    }

    override def postLogin(
                            email: String,
                            password: String
                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Auth] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email),
        "password" -> play.api.libs.json.Json.toJson(password)
      )

      _executeRequest("POST", s"/users/login", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.Auth", r, _.validate[com.gilt.cavellc.models.Auth])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def postForgotPassword(
                                     email: String
                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.Json.toJson(email)
      )

      _executeRequest("POST", s"/users/forgot-password", body = Some(payload)).map {
        case r if r.getStatusCode == 202 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 202", r.getUri)
      }
    }

    override def postResetPassword(
                                    password: String,
                                    token: String
                                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
      val payload = play.api.libs.json.Json.obj(
        "password" -> play.api.libs.json.Json.toJson(password),
        "token" -> play.api.libs.json.Json.toJson(token)
      )

      _executeRequest("POST", s"/users/reset-password", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => Unit
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getInfo()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.User]] = {
      _executeRequest("GET", s"/users/info").map {
        case r if r.getStatusCode == 200 => Some(_root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.User", r, _.validate[com.gilt.cavellc.models.User]))
        case r if r.getStatusCode == 404 => None
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 404", r.getUri)
      }
    }

    override def patchInfo(
                            firstName: _root_.scala.Option[String] = None,
                            lastName: _root_.scala.Option[String] = None,
                            password: _root_.scala.Option[String] = None
                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.User] = {
      val payload = play.api.libs.json.Json.obj(
        "first_name" -> play.api.libs.json.Json.toJson(firstName),
        "last_name" -> play.api.libs.json.Json.toJson(lastName),
        "password" -> play.api.libs.json.Json.toJson(password)
      )

      _executeRequest("PATCH", s"/users/info", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("com.gilt.cavellc.models.User", r, _.validate[com.gilt.cavellc.models.User])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizations()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.UserOrganization]] = {
      _executeRequest("GET", s"/users/organizations").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.UserOrganization]", r, _.validate[Seq[com.gilt.cavellc.models.UserOrganization]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getOrganizationsAndTeamsByName(
                                                 name: String
                                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.UserTeam]] = {
      _executeRequest("GET", s"/users/organizations/${_root_.com.gilt.cavellc.PathSegment.encode(name, "UTF-8")}/teams").map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.UserTeam]", r, _.validate[Seq[com.gilt.cavellc.models.UserTeam]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }

    override def getSearch(
                            q: String
                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.User]] = {
      val queryParameters = Seq(
        Some("q" -> q)
      ).flatten

      _executeRequest("GET", s"/users/search", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => _root_.com.gilt.cavellc.Client.parseJson("Seq[com.gilt.cavellc.models.User]", r, _.validate[Seq[com.gilt.cavellc.models.User]])
        case r => throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", r.getUri)
      }
    }
  }

  def _logRequest(request: Request) {
    logger.info("_logRequest: " + request)
  }

  def _requestBuilder(method: String, path: String): RequestBuilder = {
    val builder = new RequestBuilder(method)
      .setUrl(apiUrl + path)
      .addHeader("User-Agent", Constants.UserAgent)
      .addHeader("X-Apidoc-Version", Constants.Version)
      .addHeader("X-Apidoc-Version-Major", Constants.VersionMajor.toString)

    auth.fold(builder) {
      case Authorization.Basic(username, password) => {
        builder.setRealm(
          new Realm.RealmBuilder()
            .setPrincipal(username)
            .setUsePreemptiveAuth(true)
            .setScheme(Realm.AuthScheme.BASIC)
            .build()
        )
      }
      case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
    }
  }

  def _executeRequest(
                       method: String,
                       path: String,
                       queryParameters: Seq[(String, String)] = Seq.empty,
                       body: Option[play.api.libs.json.JsValue] = None
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.ning.http.client.Response] = {
    val request = _requestBuilder(method, path)

    queryParameters.foreach { pair =>
      request.addQueryParameter(pair._1, pair._2)
    }

    val requestWithParamsAndBody = body.fold(request) { b =>
      val serialized = play.api.libs.json.Json.stringify(b)
      request.setBody(serialized).addHeader("Content-type", "application/json; charset=UTF-8")
    }

    val finalRequest = requestWithParamsAndBody.build()
    _logRequest(finalRequest)

    val result = scala.concurrent.Promise[com.ning.http.client.Response]()
    asyncHttpClient.executeRequest(finalRequest,
      new AsyncCompletionHandler[Unit]() {
        override def onCompleted(r: com.ning.http.client.Response) = result.success(r)
        override def onThrowable(t: Throwable) = result.failure(t)
      }
    )
    result.future
  }

}

object Client {

  private lazy val defaultAsyncHttpClient = {
    new AsyncHttpClient(
      new AsyncHttpClientConfig.Builder()
        .setExecutorService(java.util.concurrent.Executors.newCachedThreadPool())
        .build()
    )
  }

  def parseJson[T](
                    className: String,
                    r: _root_.com.ning.http.client.Response,
                    f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
                    ): T = {
    f(play.api.libs.json.Json.parse(r.getResponseBody("UTF-8"))) match {
      case play.api.libs.json.JsSuccess(x, _) => x
      case play.api.libs.json.JsError(errors) => {
        throw new com.gilt.cavellc.errors.FailedRequest(r.getStatusCode, s"Invalid json for class[" + className + "]: " + errors.mkString(" "), r.getUri)
      }
    }
  }

}

sealed trait Authorization
object Authorization {
  case class Basic(username: String, password: Option[String] = None) extends Authorization
}

trait Alerts {
  /**
   * Retrieve the list of alerts associated with the given organization.
   */
  def getOrganizationsByOrganization(
                                      organization: String,
                                      limit: _root_.scala.Option[Int] = None,
                                      offset: _root_.scala.Option[Int] = None
                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Alert]]

  /**
   * Create a new alert for the given organization.
   */
  def postOrganizationsByOrganization(
                                       organization: String,
                                       description: String,
                                       enabled: Boolean,
                                       period: String,
                                       condition: String,
                                       handbookUrl: _root_.scala.Option[String] = None,
                                       routing: _root_.scala.Option[Map[String, String]] = None
                                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert]

  /**
   * Update an alert for the given organization.
   */
  def patchOrganizationsByOrganizationAndId(
                                             organization: String,
                                             id: String,
                                             description: _root_.scala.Option[String] = None,
                                             enabled: _root_.scala.Option[Boolean] = None,
                                             period: _root_.scala.Option[String] = None,
                                             handbookUrl: _root_.scala.Option[String] = None,
                                             routing: _root_.scala.Option[Map[String, String]] = None
                                             )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert]

  /**
   * Retrieve the alert with given alert ID for the given organization.
   */
  def getOrganizationsByOrganizationAndId(
                                           organization: String,
                                           id: String
                                           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Alert]]

  /**
   * Delete the alert with the given ID from the given organization.
   */
  def deleteOrganizationsByOrganizationAndId(
                                              organization: String,
                                              id: String
                                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  /**
   * Retrieve the list of alerts associated with the given team of the given
   * organization.
   */
  def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                     organization: String,
                                                     team: String,
                                                     limit: _root_.scala.Option[Int] = None,
                                                     offset: _root_.scala.Option[Int] = None
                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Alert]]

  /**
   * Create a new alert for the given team of the given organization.
   */
  def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                      organization: String,
                                                      team: String,
                                                      description: String,
                                                      enabled: Boolean,
                                                      period: String,
                                                      condition: String,
                                                      handbookUrl: _root_.scala.Option[String] = None,
                                                      routing: _root_.scala.Option[Map[String, String]] = None
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert]

  /**
   * Update an alert for the given team of the given organization.
   */
  def patchOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                            organization: String,
                                                            team: String,
                                                            id: String,
                                                            description: _root_.scala.Option[String] = None,
                                                            enabled: _root_.scala.Option[Boolean] = None,
                                                            period: _root_.scala.Option[String] = None,
                                                            handbookUrl: _root_.scala.Option[String] = None,
                                                            routing: _root_.scala.Option[Map[String, String]] = None
                                                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Alert]

  /**
   * Retrieve the alert with given alert ID for the given team of the given
   * organization.
   */
  def getOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                          organization: String,
                                                          team: String,
                                                          id: String
                                                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Alert]]

  /**
   * Delete the alert with the given ID from the given team of the given
   * organization.
   */
  def deleteOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                             organization: String,
                                                             team: String,
                                                             id: String
                                                             )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]
}

trait Metrics {
  /**
   * Create organization metric data.
   */
  def postOrganizationsByOrganization(
                                       organization: String,
                                       metrics: Seq[com.gilt.cavellc.models.Metric]
                                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Create team metric data.
   */
  def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                      organization: String,
                                                      team: String,
                                                      metrics: Seq[com.gilt.cavellc.models.Metric]
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Retrieve information about available organization metrics.
   */
  def getOrganizationsAndMetricNamesByOrganization(
                                                    organization: String
                                                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.MetricInfo]]

  /**
   * Retrieve information about available team metrics.
   */
  def getOrganizationsAndTeamsAndMetricNamesByOrganizationAndTeam(
                                                                   organization: String,
                                                                   team: String
                                                                   )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.MetricInfo]]

  /**
   * Evaluate data for organization metrics.
   */
  def getOrganizationsAndCheckMetricsByOrganization(
                                                     organization: String,
                                                     condition: String,
                                                     start: _root_.org.joda.time.DateTime,
                                                     end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                     interval: _root_.scala.Option[Int] = None
                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]]

  /**
   * Evaluate data for team metrics.
   */
  def getOrganizationsAndTeamsAndCheckMetricsByOrganizationAndTeam(
                                                                    organization: String,
                                                                    team: String,
                                                                    condition: String,
                                                                    start: _root_.org.joda.time.DateTime,
                                                                    end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                                    interval: _root_.scala.Option[Int] = None
                                                                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]]

  /**
   * Retrieve data for an organization metric.
   */
  def getOrganizationsByOrganization(
                                      organization: String,
                                      metric: String,
                                      tags: _root_.scala.Option[String] = None,
                                      aggregator: com.gilt.cavellc.models.Aggregator,
                                      period: Int,
                                      start: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                      end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                      limit: _root_.scala.Option[Int] = None
                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]]

  /**
   * Retrieve data for a team metric.
   */
  def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                     organization: String,
                                                     team: String,
                                                     metric: String,
                                                     tags: _root_.scala.Option[String] = None,
                                                     aggregator: com.gilt.cavellc.models.Aggregator,
                                                     period: Int,
                                                     start: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                     end: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                                                     limit: _root_.scala.Option[Int] = None
                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.MetricDataBulk]]
}

trait Organizations {
  /**
   * Create a new organization.
   */
  def post(
            name: String,
            email: String,
            notificationUrl: String
            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Organization]

  /**
   * Retrieve organization with given name.
   */
  def getByName(
                 name: String
                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Organization]]

  /**
   * Update the organization with the given name.
   */
  def patchByName(
                   name: String,
                   email: _root_.scala.Option[String] = None,
                   notificationUrl: _root_.scala.Option[String] = None
                   )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Organization]

  /**
   * Delete the organization with the given name.
   */
  def deleteByName(
                    name: String
                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  def deleteMetricNamesByNameAndMetric(
                                        name: String,
                                        metric: String
                                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  /**
   * Retrieve organization users.
   */
  def getUsersByName(
                      name: String
                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Member]]

  /**
   * Add user to organization.
   */
  def postUsersByName(
                       name: String,
                       email: String,
                       role: com.gilt.cavellc.models.Role
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Modify role for user in organization.
   */
  def patchUsersByNameAndEmail(
                                name: String,
                                email: String,
                                role: com.gilt.cavellc.models.Role
                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Delete user from organization.
   */
  def deleteUsersByNameAndEmail(
                                 name: String,
                                 email: String
                                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]
}

trait Statuses {
  /**
   * Get list of current and recent issues affecting CAVE
   */
  def getStatus()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Status]]
}

trait Teams {
  /**
   * Retrieve the list of teams associated with the given organization.
   */
  def getOrganizationsByOrganization(
                                      organization: String
                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Team]]

  /**
   * Create a new team for the given organization.
   */
  def postOrganizationsByOrg(
                              org: String,
                              name: String
                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Team]

  /**
   * Retrieve the team with given team name for the given organization.
   */
  def getOrganizationsByOrganizationAndTeam(
                                             organization: String,
                                             team: String
                                             )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Team]]

  def deleteOrganizationsAndMetricNamesByOrganizationNameAndTeamNameAndMetric(
                                                                               organizationName: String,
                                                                               teamName: String,
                                                                               metric: String
                                                                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  /**
   * Retrieve the users for the team with given team name for the given organization.
   */
  def getOrganizationsAndUsersByOrganizationAndTeam(
                                                     organization: String,
                                                     team: String
                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Member]]

  /**
   * Add user to the team with given team name for the given organization.
   */
  def postOrganizationsAndUsersByOrganizationAndTeam(
                                                      organization: String,
                                                      team: String,
                                                      email: String,
                                                      role: com.gilt.cavellc.models.Role
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Modify role of user in team.
   */
  def patchOrganizationsAndUsersByOrganizationAndTeamAndEmail(
                                                               organization: String,
                                                               team: String,
                                                               email: String,
                                                               role: com.gilt.cavellc.models.Role
                                                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Remove user from team.
   */
  def deleteOrganizationsAndUsersByOrganizationAndTeamAndEmail(
                                                                organization: String,
                                                                team: String,
                                                                email: String
                                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  /**
   * Delete the team with the given name from the given organization.
   */
  def deleteOrganizationsByOrganizationAndTeam(
                                                organization: String,
                                                team: String
                                                )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]
}

trait Tokens {
  /**
   * Retrieve the list of tokens associated with the given organization.
   */
  def getOrganizationsByOrganization(
                                      organization: String
                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Token]]

  /**
   * Create a new token for the given organization.
   */
  def postOrganizationsByOrganization(
                                       organization: String,
                                       description: String
                                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Token]

  /**
   * Retrieve the token with given token ID for the given organization.
   */
  def getOrganizationsByOrganizationAndId(
                                           organization: String,
                                           id: String
                                           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Token]]

  /**
   * Delete the token with the given ID from the given organization.
   */
  def deleteOrganizationsByOrganizationAndId(
                                              organization: String,
                                              id: String
                                              )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]

  /**
   * Retrieve the list of tokens associated with the given team of the given
   * organization.
   */
  def getOrganizationsAndTeamsByOrganizationAndTeam(
                                                     organization: String,
                                                     team: String
                                                     )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.Token]]

  /**
   * Create a new token for the given team of the given organization.
   */
  def postOrganizationsAndTeamsByOrganizationAndTeam(
                                                      organization: String,
                                                      team: String,
                                                      description: String
                                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Token]

  /**
   * Retrieve the token with given token ID for the given team of the given
   * organization.
   */
  def getOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                          organization: String,
                                                          team: String,
                                                          id: String
                                                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.Token]]

  /**
   * Delete the token with the given ID from the given team of the given
   * organization.
   */
  def deleteOrganizationsAndTeamsByOrganizationAndTeamAndId(
                                                             organization: String,
                                                             team: String,
                                                             id: String
                                                             )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[Unit]]
}

trait Users {
  /**
   * Register an email address for a new user
   */
  def postRegister(
                    email: String
                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Confirm an email address and complete user registration
   */
  def postConfirm(
                   firstName: String,
                   lastName: String,
                   password: String,
                   confirmationToken: String
                   )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.User]

  /**
   * Authenticate a user for using the CAVE API
   */
  def postLogin(
                 email: String,
                 password: String
                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.Auth]

  /**
   * Request password reset for a user
   */
  def postForgotPassword(
                          email: String
                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Reset the password for a user
   */
  def postResetPassword(
                         password: String,
                         token: String
                         )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

  /**
   * Retrieve user information
   */
  def getInfo()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[_root_.scala.Option[com.gilt.cavellc.models.User]]

  /**
   * Update user information
   */
  def patchInfo(
                 firstName: _root_.scala.Option[String] = None,
                 lastName: _root_.scala.Option[String] = None,
                 password: _root_.scala.Option[String] = None
                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.cavellc.models.User]

  /**
   * Retrieve organizations for this user
   */
  def getOrganizations()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.UserOrganization]]

  /**
   * Retrieve teams in this organization for this user
   */
  def getOrganizationsAndTeamsByName(
                                      name: String
                                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.UserTeam]]

  /**
   * Search users that match the given substring
   */
  def getSearch(
                 q: String
                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[com.gilt.cavellc.models.User]]
}

package errors {

case class FailedRequest(responseCode: Int, message: String, requestUri: _root_.java.net.URI) extends Exception(s"HTTP $responseCode: $message")

}

object PathSegment {
  // See https://github.com/playframework/playframework/blob/2.3.x/framework/src/play/src/main/scala/play/utils/UriEncoding.scala
  def encode(s: String, inputCharset: String): String = {
    val in = s.getBytes(inputCharset)
    val out = new java.io.ByteArrayOutputStream()
    for (b <- in) {
      val allowed = segmentChars.get(b & 0xFF)
      if (allowed) {
        out.write(b)
      } else {
        out.write('%')
        out.write(upperHex((b >> 4) & 0xF))
        out.write(upperHex(b & 0xF))
      }
    }
    out.toString("US-ASCII")
  }

  private def upperHex(x: Int): Int = {
    // Assume 0 <= x < 16
    if (x < 10) (x + '0') else (x - 10 + 'A')
  }

  private val segmentChars: java.util.BitSet = membershipTable(pchar)

  private def pchar: Seq[Char] = {
    val alphaDigit = for ((min, max) <- Seq(('a', 'z'), ('A', 'Z'), ('0', '9')); c <- min to max) yield c
    val unreserved = alphaDigit ++ Seq('-', '.', '_', '~')
    val subDelims = Seq('!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '=')
    unreserved ++ subDelims ++ Seq(':', '@')
  }

  private def membershipTable(chars: Seq[Char]): java.util.BitSet = {
    val bits = new java.util.BitSet(256)
    for (c <- chars) { bits.set(c.toInt) }
    bits
  }
}
}